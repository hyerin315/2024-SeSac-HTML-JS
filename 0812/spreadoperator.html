<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 1) ES6에서 새로 도입한 연산자(문법)
    // 2) ...(점점점) : 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서(전개하여) 개별적인 목록을 생성
    // 3) 스프레드 연산자는 array, String, Map, Set, DOM Node List(Dom Collection), Arguments와 같이 for ... of 문으로 순회할 수 있는 Iterable에만 사용가능

    //ES5 (스프레드 연산자 없을 때)
    const array = [3,4,5]; // 배열
    // const v1 = array[0];
    // const v2 = array[1];
    // const v3 = array[2];

    // console.log(v1, v2, v3);

    //ES6
    // const[v1, v2, v3] = array;
    // console.log(v1, v2, v3);


    // 4) 변수의 갯수와 Iterable의 갯수가 반드시 일치할 필요가 없음
    const[v1, v2] = array;
    console.log(v1, v2);


    [a, b] = [1];
    console.log(a. b); // undefined

    [a, b = 0] = [1]; // b = 0 : default 설정 -> 값이 할당되지 않았을 때 들어감
    console.log(a, b);


    // 5) 배열 디스트럭처링(구조분해 할당) 할당을 위한 변수에 rest parameter와 유사하게 rest요소 ...(점점점)을 사용할 수 있음
    //    단, rest 요소는 반드시 마지막에 위치해야함 (앞에 두면, 앞에서 다 받아버리기 때문)
    const [x, ...y] = [1, 2, 3];  // y : 2, 3를 배열로 받음
    console.log(x, y); // 1, [2, 3]

    const [a1, ...z1] = [1, 2, 3, true, {name:'jimin'}]; // y : 2, 3, ~ 함수까지 받음
    console.log(a1, z1);

    // 응용하기
    const array1 = [1, 2, 3, 4, 5];
    const array2 = [...array1, 6, 7, 8, 9]; // 펼쳐서 전개함(내부적으로 for...of로 뽑아서 전개함)
    console.log(array2);
    
  </script>
</body>
</html>